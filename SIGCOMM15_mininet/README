This lab replicates the original SIGCOMM2015 one but in Mininet.

First, create the network by running:

```bash
python network.py -n
```

The first command will spawn the network (square topology), and you will land
in the mininet CLI. The second on will spawn an instance of a controller running
the Simple algorithm.

Additionally, you can append a --debug parameter to received detailed logs.

Once you see that the network has been created, and that the southbound
Fibbing controller seems to have a stable view of the topology (the log entries
'[   INFO] update_graph: LSA update yielded +1 -0 edges changes' should stop
when that is the case), you can start the 'application' component of the
controller:

```bash
python network.py -c
```

In this case, it simply spreads the traffic going towards d1 and d2.

Beside the 'usual' mininet cli command, 2 extra ones can be useful:
    1. route <destination> : Will output the routing table towards the given
    destination for all routers.
    Example: route d1

    2. ip <address> : Will show the node name for the given ip address

Additional commands will be listed in the 'help' command.

The quickest way to test if the controller is working properly is to run
traceroute before and after spawning the 'application' controller
(network.py -c).

```bash
s1 traceroute -4n d1
s1 traceroute -4n d2
```

The routes should no longer be identical to reach d1 and d2 once the application
controller is started.

If you want to obtain the 'graphs' that can be seen in the paper or in the
demo on the website, you can run UDP iperf sessions between s1-d1 and s2-d2 and
monitor the achieved throughput on the server logs, or watch it in realtime
using e.g. 'speedometer d1-eth0' in another console.
(after having spawned a xterm for d1 via xterm d1)
